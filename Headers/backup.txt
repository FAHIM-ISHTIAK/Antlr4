parser grammar C8086Parser;

options {
    tokenVocab = C8086Lexer;
}

@parser::header {
    #include <iostream>
    #include <fstream>
    #include <string>
    #include <cstdlib>
    #include "C8086Lexer.h"
	#include "Utills/2105004_SymbolTable.hpp"

    extern std::ofstream parserLogFile;
    extern std::ofstream errorFile;
	extern std::ofstream assemblyFile;

    extern int syntaxErrorCount;
}

@parser::members {

	SymbolTable *symbolTable = new SymbolTable(7,parserLogFile);
	bool hasInserted = false;
	SymbolInfo *existing, *existing2;
	string code = "";
	string str = "";
	string str2 = "";
	string str3 = "";
	string forlabel = "";
	string whilelabel = "";
	string datacode = "";
	int labelCount = 0;
	int tempVarCount = 0;
	int stackOffset = 0;
	bool isGlobal = false;
	stack<string> labelStack;

	std::string newLabel() {
		return "L" + std::to_string(labelCount++);
	}

	std::string newTempVariable() {
		std::string tempVar = "temp" + std::to_string(tempVarCount++);
		stackOffset += 2;
		code += "SUB SP, 2\n";
		SymbolAdditionalInfo info = SymbolAdditionalInfo();
		info.offset = stackOffset;
		info.isGlobal = (symbolTable->getCurrentScopeId() == "1")? true : false;
		symbolTable->Insert(tempVar, "ID", info);
		return tempVar;
	}

	void writeIntoparserLogFile(const std::string message) {
        if (!parserLogFile) {
            std::cout << "Error opening parserLogFile.txt" << std::endl;
            return;
        }

        parserLogFile << message << std::endl;
        parserLogFile.flush();
    }

	void writeIntoAssemblyFile(const std::string message) {
		if (!assemblyFile) {
			std::cout << "Error opening assemblyOutput.asm" << std::endl;
			return;
		}

		assemblyFile << message << std::endl;
		assemblyFile.flush();
	}

	// void notifyErrorListeners(antlr4::Token *offendingToken, const std::string &msg, std::exception_ptr e) override {
    //     syntaxErrorCount++;
    //     size_t line = offendingToken->getLine();
    //     std::string errorMsg = "Line " + std::to_string(line) + ": Syntax error\n";
    //     writeIntoErrorFile(errorMsg);
    // }

    void writeIntoErrorFile(const std::string message) {
        if (!errorFile) {
            std::cout << "Error opening errorFile.txt" << std::endl;
            return;
        }
        errorFile << message << std::endl;
        errorFile.flush();
    }
}


start : pg=program
	{
		symbolTable->PrintAllScopeTable();
		delete symbolTable;
		str = ".model small\n.stack 1000h\n.data\n";
		str += datacode;
		str += "\n.code\n";
		code = str + code;
str = "new_line proc\n"
"    push ax\n"
"    push dx\n"
"    mov ah,2\n"
"    mov dl,0Dh\n"
"    int 21h\n"
"    mov ah,2\n"
"    mov dl,0Ah\n"
"    int 21h\n"
"    pop dx\n"
"    pop ax\n"
"    ret\n"
"    new_line endp\n"
"print_output proc  ;print what is in ax\n"
"    push ax\n"
"    push bx\n"
"    push cx\n"
"    push dx\n"
"    push si\n"
"    lea si,number\n"
"    mov bx,10\n"
"    add si,4\n"
"    cmp ax,0\n"
"    jnge negate\n"
"print:\n"
"    xor dx,dx\n"
"    div bx\n"
"    mov [si],dl\n"
"    add [si],'0'\n"
"    dec si\n"
"    cmp ax,0\n"
"    jne print\n"
"    inc si\n"
"    lea dx,si\n"
"    mov ah,9\n"
"    int 21h\n"
"    pop si\n"
"    pop dx\n"
"    pop cx\n"
"    pop bx\n"
"    pop ax\n"
"    ret\n"
"negate:\n"
"    push ax\n"
"    mov ah,2\n"
"    mov dl,'-'\n"
"    int 21h\n"
"    pop ax\n"
"    neg ax\n"
"    jmp print\n"
"print_output endp\n";
code += str;

writeIntoAssemblyFile(code);
	}
	;

program : pg=program unt=unit {
	writeIntoparserLogFile("Line " + std::to_string($unt.stop->getLine()) + ":" + " program : program unit\n");
	writeIntoparserLogFile($pg.text + "\n" + $unt.text + "\n\n");
}
	| unt=unit {
	writeIntoparserLogFile("Line " + std::to_string($unt.stop->getLine()) + ":" + " program : unit\n");
	writeIntoparserLogFile($unt.text + "\n");
	}
	;
	
unit : var_dec=var_declaration { 
	writeIntoparserLogFile("Line " + std::to_string($var_dec.start->getLine()) + ":" + " unit : var_declaration\n"); 
	writeIntoparserLogFile($var_dec.text + "\n\n"); 
}
     | func_dec=func_declaration {
		writeIntoparserLogFile("Line " + std::to_string($func_dec.stop->getLine()) + ":" + " unit : func_declaration\n");
		writeIntoparserLogFile($func_dec.text + "\n\n");
	 }
     | func_def=func_definition {
		writeIntoparserLogFile("Line " + std::to_string($func_def.stop->getLine()) + ":" + " unit : func_definition\n");
		writeIntoparserLogFile($func_def.text + "\n");
	 }
     ;

func_declaration : t=type_specifier id=ID {
	if(symbolTable->LookUp($id.text)){
		writeIntoparserLogFile("Error at line " + std::to_string($id->getLine()) + ":" + " Multiple declaration of " + $id.text + "\n");
		writeIntoErrorFile("Error at line " + std::to_string($id->getLine()) + ":" + " Multiple declaration of " + $id.text + "\n");
		syntaxErrorCount++;
	} 
} lp=LPAREN pl=parameter_list rp=RPAREN sm=SEMICOLON {
			writeIntoparserLogFile("Line " + std::to_string($sm->getLine()) + ":" + " func_declaration : type_specifier ID LPAREN RPAREN SEMICOLON\n");
			writeIntoparserLogFile($t.text + " " + $id.text + $lp.text + $pl.text +$rp.text + $sm.text + "\n\n");
			if(!symbolTable->LookUp($id.text)){
				SymbolAdditionalInfo info = SymbolAdditionalInfo();
				info.isFunction = true;
				info.parameters = $pl.params;
				info.returnType = $t.text;
				symbolTable->Insert($id.text, "ID", info);
			}
}
		| t=type_specifier id=ID {
		if(symbolTable->LookUp($id.text)){
		writeIntoErrorFile("Line " + std::to_string($id->getLine()) + " - Error: Function '" + $id.text + "' already declared.");
		writeIntoparserLogFile("Line " + std::to_string($id->getLine()) + " - Error: Function '" + $id.text + "' already declared.");
		syntaxErrorCount++;
	} 
		} lp=LPAREN rp=RPAREN sm=SEMICOLON {
			writeIntoparserLogFile("Line " + std::to_string($sm->getLine()) + ":" + " func_declaration : type_specifier ID LPAREN RPAREN SEMICOLON\n");
			writeIntoparserLogFile($t.text + " " + $id.text + $lp.text + $rp.text + $sm.text + "\n\n");
			if(!symbolTable->LookUp($id.text)){
				SymbolAdditionalInfo info = SymbolAdditionalInfo();
				info.isFunction = true;
				info.returnType = $t.text;
				hasInserted = symbolTable->Insert($id.text, "ID", info);
			}
		}
		;
		 
func_definition : t=type_specifier id=ID {
	existing = symbolTable->LookUp($id.text);
	if (existing) {
			if(!existing->additionalInfo.isFunction){
				writeIntoparserLogFile("Error at line " + std::to_string($id->getLine()) + ":" + " Multiple declaration of " + $id.text + "\n");
				writeIntoErrorFile("Error at line " + std::to_string($id->getLine()) + ":" + " Multiple declaration of " + $id.text + "\n");
				syntaxErrorCount++;
			}
			else if(existing->additionalInfo.isDefined) {
				writeIntoparserLogFile("Line# " + std::to_string($id->getLine()) + " - Error: Function '" + $id.text + "' is already defined.");
                writeIntoErrorFile("Line# " + std::to_string($id->getLine()) + " - Error: Function '" + $id.text + "' is already defined.");
                syntaxErrorCount++;
            }
        }
		else{
			SymbolAdditionalInfo info = SymbolAdditionalInfo();
			info.deleted = true;
			info.isFunction = true;
			info.isDefined = true;
			info.returnType = $t.text;
			symbolTable->Insert($id.text, "ID",  info);
		}
} lp=LPAREN { symbolTable->Enter_scope(); } pl=parameter_list { 
if($pl.params.size() == $pl.names.size()){
		for(int i = 0; i < $pl.params.size(); i++){
			if($pl.names[i] == "error"){
				// writeIntoparserLogFile("Error at line " + std::to_string($id->getLine()) + ": syntax error, unexpected ADDOP, expecting RPAREN or COMMA\n");
				// writeIntoErrorFile("Error at line " + std::to_string($id->getLine()) + ": syntax error, unexpected ADDOP, expecting RPAREN or COMMA\n");
				writeIntoparserLogFile("Error at line " + std::to_string($id->getLine()) + ": syntax error\n");
				writeIntoErrorFile("Error at line " + std::to_string($id->getLine()) + ": syntax error\n");
				writeIntoparserLogFile("Error at line " + std::to_string($id->getLine()) + ": " + std::to_string(i+1) + "th parameter's name not given in function definition of " + $id.text + "\n");
				writeIntoErrorFile("Error at line " + std::to_string($id->getLine()) + ": " + std::to_string(i+1) + "th parameter's name not given in function definition of " + $id.text + "\n");
				syntaxErrorCount++;
				continue;
			}
			if(symbolTable->LookUp2($pl.names[i])){
				writeIntoparserLogFile("Error at line " + std::to_string($id->getLine()) + ":" + " Multiple declaration of " + $pl.names[i] + " in parameter" + "\n");
				writeIntoErrorFile("Error at line " + std::to_string($id->getLine()) + ":" + " Multiple declaration of " + $pl.names[i] + " in parameter" + "\n");
				syntaxErrorCount++;
				continue;
			}
		SymbolAdditionalInfo info = SymbolAdditionalInfo();
		info.dataType = $pl.params[i];
		symbolTable->Insert($pl.names[i], "ID", info);
	}
}
 } rp=RPAREN {
		existing = symbolTable->LookUp($id.text);
		if(existing && existing->additionalInfo.isFunction){
			if(!existing->additionalInfo.isDefined){
				if(existing->additionalInfo.parameters != $pl.params) {
					syntaxErrorCount++;
					if(existing->additionalInfo.parameters.size() != $pl.params.size()){
						writeIntoErrorFile("Error at line " + std::to_string($id->getLine()) + ":" + " Total number of arguments mismatch with declaration in function " + $id.text + "\n");
						writeIntoparserLogFile("Error at line " + std::to_string($id->getLine()) + ":" + " Total number of arguments mismatch with declaration in function " + $id.text + "\n");
					}
					}
				if(existing->additionalInfo.returnType != $t.text) {
					writeIntoparserLogFile("Error at line " + std::to_string($id->getLine()) + ":" + " Return type mismatch with function declaration in function " + $id.text + "\n");
					writeIntoErrorFile("Error at line " + std::to_string($id->getLine()) + ":" + " Return type mismatch with function declaration in function " + $id.text + "\n");
					syntaxErrorCount++;
				}
				existing->additionalInfo.isDefined = true;
			}
			else{
				existing->additionalInfo.parameters = $pl.params;
			}
		}
 } cm_stmt=compound_statement[true] {
			writeIntoparserLogFile("Line " + std::to_string($cm_stmt.stop->getLine()) + ":" + " func_definition : type_specifier ID LPAREN parameter_list RPAREN compound_statement\n");
			writeIntoparserLogFile($t.text + " " + $id.text + $lp.text + $pl.text + $rp.text + $cm_stmt.text + "\n");
}
		| t=type_specifier id=ID {
	existing = symbolTable->LookUp($id.text);
	if (existing) {
			if(!existing->additionalInfo.isFunction){
				writeIntoparserLogFile("Error at line " + std::to_string($id->getLine()) + ":" + " Multiple declaration of " + $id.text + "\n");
				writeIntoErrorFile("Error at line " + std::to_string($id->getLine()) + ":" + " Multiple declaration of " + $id.text + "\n");
				syntaxErrorCount++;
			}
			else if(existing->additionalInfo.isDefined) {
				writeIntoparserLogFile("Line# " + std::to_string($id->getLine()) + " - Error: Function '" + $id.text + "' is already defined.");
                writeIntoErrorFile("Line# " + std::to_string($id->getLine()) + " - Error: Function '" + $id.text + "' is already defined.");
                syntaxErrorCount++;
            }
        }
		else{
			SymbolAdditionalInfo info = SymbolAdditionalInfo();
			info.deleted = true;
			info.isFunction = true;
			info.isDefined = true;
			info.returnType = $t.text;
			symbolTable->Insert($id.text, "ID",  info);
		}
		code += $id.text + " PROC\n";
		code += "push BP\n";
		code += "mov BP, SP\n";
		stackOffset = 0;
} lp=LPAREN { symbolTable->Enter_scope(); } rp=RPAREN {
		existing = symbolTable->LookUp($id.text);
		if(existing && existing->additionalInfo.isFunction){
			if(!existing->additionalInfo.isDefined){
				if(existing->additionalInfo.returnType != $t.text) {
					writeIntoparserLogFile("Error at line " + std::to_string($id->getLine()) + ":" + " Return type mismatch with function declaration in function " + $id.text + "\n");
					writeIntoErrorFile("Error at line " + std::to_string($id->getLine()) + ":" + " Return type mismatch with function declaration in function " + $id.text + "\n");
					syntaxErrorCount++;
				}
				if(existing->additionalInfo.parameters.size() > 0){
				writeIntoparserLogFile("Error at line " + std::to_string($id->getLine()) + ":" + " Total number of arguments mismatch with declaration in function " + $id.text + "\n");				
				writeIntoErrorFile("Error at line " + std::to_string($id->getLine()) + ":" + " Total number of arguments mismatch with declaration in function " + $id.text + "\n");
				syntaxErrorCount++;
		        }
				existing->additionalInfo.isDefined = true;
			}
		}
} cm_stmt=compound_statement[true] {
			writeIntoparserLogFile("Line " + std::to_string($cm_stmt.stop->getLine()) + ":" + " func_definition : type_specifier ID LPAREN RPAREN compound_statement\n");
			writeIntoparserLogFile($t.text + " " + $id.text + $lp.text + $rp.text + $cm_stmt.text + "\n");
			code += "mov SP, BP\n";
			code += "pop BP\n";
			code += $id.text + " ENDP\n";
	}
 		;				


parameter_list  returns [std::vector<std::string> params , std::vector<std::string> names]: pl=parameter_list cm=COMMA t=type_specifier id=ID {
	writeIntoparserLogFile("Line " + std::to_string($cm->getLine()) + ":" + " parameter_list : parameter_list COMMA type_specifier ID\n");
	writeIntoparserLogFile($pl.text + $cm.text + $t.text + " " +$id.text + "\n");
	$params = $pl.params;
    $params.push_back($t.text);
	$names = $pl.names;
	$names.push_back($id.text);
}       
        | pl=parameter_list cm=COMMA t=type_specifier op=(ADDOP|MULOP|ASSIGNOP|LOGICOP|RELOP) {
			$params = $pl.params;
			$names = $pl.names;
			$params.push_back($t.text);
			$names.push_back("error");
			// $text = $pl.text + $cm.text + $t.text;
			writeIntoparserLogFile("Line " + std::to_string($cm->getLine()) + ":" + " parameter_list : parameter_list COMMA type_specifier ID\n");
	        writeIntoparserLogFile($pl.text + $cm.text + $t.text + " " + "\n");
		}
		| pl=parameter_list cm=COMMA t=type_specifier {
	writeIntoparserLogFile("Line " + std::to_string($cm->getLine()) + ":" + " parameter_list : parameter_list COMMA type_specifier\n");
	writeIntoparserLogFile($pl.text + $cm.text + $t.text + "\n");
	$params = $pl.params;
    $params.push_back($t.text);
	$names = $pl.names;
	$names.push_back($id.text);
		}
 		| t=type_specifier id=ID {
	writeIntoparserLogFile("Line " + std::to_string($t.stop->getLine()) + ":" + " parameter_list : type_specifier ID\n");
	writeIntoparserLogFile($t.text + " " + $id.text + "\n");
	$params.push_back($t.text);
	$names.push_back($id.text);
		}
		| t=type_specifier {
	writeIntoparserLogFile("Line " + std::to_string($t.stop->getLine()) + ":" + " parameter_list : type_specifier\n");
	writeIntoparserLogFile($t.text + "\n");
	$params.push_back($t.text);
	 $names.push_back("");
		}
		| t=type_specifier op=(ADDOP|MULOP|ASSIGNOP|LOGICOP|RELOP) {
			$params.push_back($t.text);
			$names.push_back("error");
			// $text = $t.text;
			writeIntoparserLogFile("Line " + std::to_string($t.stop->getLine()) + ":" + " parameter_list : type_specifier\n");
	        writeIntoparserLogFile($t.text + "\n");
		}
 		;


compound_statement[bool IsFunction] : LCURL {
	if(!IsFunction){
	symbolTable->Enter_scope();
 }
} stmts=statements RCURL {
			writeIntoparserLogFile("Line " + std::to_string($RCURL->getLine()) + ":" + " compound_statement : LCURL statements RCURL\n");
			writeIntoparserLogFile($LCURL->getText() + "\n" + $stmts.text + "\n" + $RCURL->getText() + "\n");
			symbolTable->PrintAllScopeTable();
			symbolTable->Remove_scope();
}
 		    | LCURL {
				 if(!IsFunction){
		 symbolTable->Enter_scope();
	 }
			} RCURL {
			writeIntoparserLogFile("Line " + std::to_string($RCURL->getLine()) + ":" + " compound_statement : LCURL RCURL\n");
			writeIntoparserLogFile($LCURL->getText() + $RCURL->getText() + "\n");
			symbolTable->PrintAllScopeTable();
			symbolTable->Remove_scope();
			}
 		    ;
 		    
var_declaration 
    : t=type_specifier dl=declaration_list sm=SEMICOLON {
		cout << $dl.decls.size() << endl;
		for(int i = 0; i < $dl.decls.size(); i++) {

			SymbolAdditionalInfo info = SymbolAdditionalInfo();
			info.dataType = $t.text;
			info.isArray = $dl.decls[i].second;
			info.arraySize = $dl.arrsize[i];
			info.isGlobal = (symbolTable->getCurrentScopeId() == "1")? true : false;

			if(info.isGlobal){
				if($dl.decls[i].second){
					datacode += $dl.decls[i].first + " DW " + std::to_string($dl.arrsize[i]) + " DUP(0)\n";
				}
				else{
					datacode += $dl.decls[i].first + " DW 0\n";
				}
			}
			else{
				if($dl.decls[i].second){
					code += "SUB SP, " + std::to_string($dl.arrsize[i] * 2) + "\n";
					stackOffset += $dl.arrsize[i] * 2;
					info.offset = stackOffset;
				}
				else{
					code += "SUB SP, 2\n";
					stackOffset += 2;
					info.offset = stackOffset;
				}
			}
			symbolTable->Insert($dl.decls[i].first, "ID", info);
		}
      }

    | t=type_specifier de=declaration_list_err sm=SEMICOLON {
        writeIntoErrorFile(
            std::string("Line# ") + std::to_string($sm->getLine()) +
            " with error name: " + $de.error_name +
            " - Syntax error at declaration list of variable declaration"
        );

        syntaxErrorCount++;
      }
    ;

declaration_list_err returns [std::string error_name]: {
        $error_name = "Error in declaration list";
    };

 		 
type_specifier returns [std::string name_line]	
        : INT {
            $name_line = "type: INT at line" + std::to_string($INT->getLine());
			writeIntoparserLogFile("Line " + std::to_string($INT->getLine()) + ":" + " type_specifier : INT\n");
            writeIntoparserLogFile($INT->getText() + "\n");
        }
 		| FLOAT {
            $name_line = "type: FLOAT at line" + std::to_string($FLOAT->getLine());
			writeIntoparserLogFile("Line " + std::to_string($FLOAT->getLine()) + ":" + " type_specifier : FLOAT\n");
            writeIntoparserLogFile($FLOAT->getText() + "\n");
        }
 		| VOID {
            $name_line = "type: VOID at line" + std::to_string($VOID->getLine());
			writeIntoparserLogFile("Line " + std::to_string($VOID->getLine()) + ":" + " type_specifier : VOID\n");
            writeIntoparserLogFile($VOID->getText() + "\n");
        }
 		;
 		
declaration_list returns [std::vector<std::pair<std::string, bool>> decls, std::vector<int> arrsize]
		: decl=declaration_list COMMA ID {
			writeIntoparserLogFile("Line " + std::to_string($ID->getLine()) + ":" + " declaration_list : declaration_list COMMA ID\n");
			writeIntoparserLogFile($decl.text + $COMMA->getText() + $ID->getText() + "\n");
			$decls = $decl.decls;
			$decls.push_back({$ID->getText(), false});
			$arrsize = $decl.arrsize;
			$arrsize.push_back(0);
		}
		| decl=declaration_list COMMA ID LTHIRD CONST_INT RTHIRD {
			writeIntoparserLogFile("Line " + std::to_string($ID->getLine()) + ":" + " declaration_list : declaration_list COMMA ID LTHIRD CONST_INT RTHIRD\n");
			writeIntoparserLogFile($decl.text + $COMMA->getText() + $ID->getText() + $LTHIRD->getText() + $CONST_INT->getText() + $RTHIRD->getText() + "\n");
			$decls = $decl.decls;
			$decls.push_back({$ID->getText(), true});
			$arrsize = $decl.arrsize;
			$arrsize.push_back(std::stoi($CONST_INT->getText()));
		}
		| decl=declaration_list (ASSIGNOP|MULOP|LOGICOP|RELOP|ADDOP) ID {
			// writeIntoparserLogFile("Error at line " + std::to_string($ID->getLine()) + ": syntax error, unexpected ADDOP, expecting COMMA or SEMICOLON\n");
			// writeIntoErrorFile("Error at line " + std::to_string($ID->getLine()) + ": syntax error, unexpected ADDOP, expecting COMMA or SEMICOLON\n");
			writeIntoparserLogFile("Error at line " + std::to_string($ID->getLine()) + ":" + " syntax error\n");
			writeIntoErrorFile("Error at line " + std::to_string($ID->getLine()) + ":" + " syntax error\n");
			syntaxErrorCount++;
			$decls = $decl.decls;
			$arrsize = $decl.arrsize;
			$decls.push_back({"error_id", false});
			$arrsize.push_back(0);
		}
		| decl=declaration_list (ASSIGNOP|MULOP|LOGICOP|RELOP|ADDOP) ID LTHIRD CONST_INT RTHIRD {
			// writeIntoparserLogFile("Error at line " + std::to_string($ID->getLine()) + ": syntax error, unexpected ADDOP, expecting COMMA or SEMICOLON\n");
			// writeIntoErrorFile("Error at line " + std::to_string($ID->getLine()) + ": syntax error, unexpected ADDOP, expecting COMMA or SEMICOLON\n");
			writeIntoparserLogFile("Error at line " + std::to_string($ID->getLine()) + ":" + " syntax error\n");
			writeIntoErrorFile("Error at line " + std::to_string($ID->getLine()) + ":" + " syntax error\n");
			syntaxErrorCount++;
			$decls = $decl.decls;
			$arrsize = $decl.arrsize;
			$decls.push_back({"error_id", true});
			$arrsize.push_back(std::stoi($CONST_INT->getText()));
		}
		| ID {
			writeIntoparserLogFile("Line " + std::to_string($ID->getLine()) + ":" + " declaration_list : ID\n");
			writeIntoparserLogFile($ID->getText() + "\n");
			$decls.push_back({$ID->getText(), false});
			$arrsize.push_back(0);
		}
		| ID LTHIRD CONST_INT RTHIRD {
			writeIntoparserLogFile("Line " + std::to_string($ID->getLine()) + ":" + " declaration_list : ID LTHIRD CONST_INT RTHIRD\n");
			writeIntoparserLogFile($ID->getText() + $LTHIRD->getText() + $CONST_INT->getText() + $RTHIRD->getText() + "\n");
			$decls.push_back({$ID->getText(), true});
			$arrsize.push_back(std::stoi($CONST_INT->getText()));
		}
		;
 		  
statements : stmt=statement {
	writeIntoparserLogFile("Line " + std::to_string($stmt.stop->getLine()) + ":" + " statements : statement\n");
	writeIntoparserLogFile($stmt.text + "\n\n");
}
	   | stmts=statements stmt=statement {
	writeIntoparserLogFile("Line " + std::to_string($stmt.stop->getLine()) + ":" + " statements : statements statement\n");
	writeIntoparserLogFile($stmts.text + "\n" + $stmt.text +"\n");
	   }
	   ;
	   
statement : var_dec=var_declaration {
	writeIntoparserLogFile("Line " + std::to_string($var_dec.stop->getLine()) + ":" + " statement : var_declaration\n");
	writeIntoparserLogFile($var_dec.text + "\n");
}
	  | expr_stmt=expression_statement {
	writeIntoparserLogFile("Line " + std::to_string($expr_stmt.stop->getLine()) + ":" + " statement : expression_statement\n");
	writeIntoparserLogFile($expr_stmt.text +"\n");
	  }
	  | cm_stmt=compound_statement[false] {
	writeIntoparserLogFile("Line " + std::to_string($cm_stmt.stop->getLine()) + ":" + " statement : compound_statement\n");
	writeIntoparserLogFile($cm_stmt.text +"\n");
	  }
	  | fr=FOR lp=LPAREN expr_stmt1=expression_statement {
		forlabel = newLabel();
		code += forlabel + ":\n";
	  } expr_stmt2=expression_statement {
		existing = symbolTable->LookUp($expr_stmt2.place);
		if(existing) {
			cout << "In for statement" << endl;
			if(existing->additionalInfo.isGlobal){
				code += std::string("MOV AX, ") + existing->getName() + "\n";
				code += "CMP AX, 0\n";
				str3 = newLabel();
				code += "JE " + str3 + "\n";
			}
			else{
				code += std::string("MOV AX, [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
				code += "CMP AX, 0\n";
				str3 = newLabel();
				code += "JE " + str3 + "\n";
			}
		}
	  } expr=expression rp=RPAREN stmt=statement {
		code += "JMP " + forlabel + "\n";
		code += str3 + ":\n";

	  }
	  | iff=IF lp=LPAREN expr=expression rp=RPAREN {
		existing = symbolTable->LookUp($expr.place);
		if(existing) {
			cout << "In if statement1" << endl;
			if(existing->additionalInfo.isArray){

			}
			else{
				if(existing->additionalInfo.isGlobal){
					code += std::string("MOV AX, ") + existing->getName() + "\n";
					str = newLabel();
					code += "CMP AX, 0\n";
					code += "JE " + str + "\n";
				}
				else{
					code += std::string("MOV AX, [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
					str = newLabel();
					code += "CMP AX, 0\n";
					code += "JE " + str + "\n";
				}
			}
		}
	  } stmt=statement {
		code += str + ":\n";
	  }
	  | iff=IF lp=LPAREN expr=expression rp=RPAREN {
		existing = symbolTable->LookUp($expr.place);
		if(existing) {
			cout << "In if statement2" << endl;
			if(existing->additionalInfo.isArray){

			}
			else{
				if(existing->additionalInfo.isGlobal){
					code += std::string("MOV AX, ") + existing->getName() + "\n";
					str = newLabel();
					code += "CMP AX, 0\n";
					code += "JE " + str + "\n";
				}
				else{
					code += std::string("MOV AX, [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
					str = newLabel();
					code += "CMP AX, 0\n";
					code += "JE " + str + "\n";
				}
			}
		}
	  } stmt1=statement {
		str2 = newLabel();
		labelStack.push(str2);
		code += "JMP " + str2 + "\n";
	  } els=ELSE {
		code += str + ":\n";
	  } stmt2=statement {
		code += labelStack.top() + ":\n";
		labelStack.pop();
	  }
	  | whl=WHILE lp=LPAREN {
		whilelabel = newLabel();
		code += whilelabel + ":\n";
	  } expr=expression {
		str3 = newLabel();
		existing = symbolTable->LookUp($expr.place);
		if(existing) {
			cout << "In while statement" << endl;
			if(existing->additionalInfo.isGlobal){
				code += std::string("MOV AX, ") + existing->getName() + "\n";
				code += "CMP AX, 0\n";
				code += "JE " + str3 + "\n";
			}
			else{
				code += std::string("MOV AX, [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
				code += "CMP AX, 0\n";
				code += "JE " + str3 + "\n";
			}
		}
	  } rp=RPAREN stmt=statement {

		code += "JMP " + whilelabel + "\n";
		code += str3 + ":\n";
	  }
	  | prln=PRINTLN lp=LPAREN id=ID rp=RPAREN sm=SEMICOLON {
	writeIntoparserLogFile("Line " + std::to_string($prln->getLine()) + ":" + " statement : PRINTLN LPAREN ID RPAREN SEMICOLON\n");
	writeIntoparserLogFile($prln.text + $lp.text + $id.text + $rp.text + $sm.text + "\n");
	existing = symbolTable->LookUp($id.text);
	cout << "Here in print statement" << endl;
	if(existing) {
		if(existing->additionalInfo.isArray) {

		}
		else{
			if(existing->additionalInfo.isGlobal){
				code += std::string("MOV AX, ") + existing->getName() + "\n";
				code += "call print_output\n";
			}
			else{
				code += std::string("MOV AX, [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
				code += "call print_output\n"; 
			}
		}
	}
	else {
		cout<< "Error in print statement" << endl;
	}
	  }
	  | rtn=RETURN expr=expression sm=SEMICOLON {
	writeIntoparserLogFile("Line " + std::to_string($rtn->getLine()) + ":" + " statement : RETURN expression SEMICOLON\n");
	writeIntoparserLogFile($rtn.text + " " + $expr.text + $sm.text + "\n\n");
	  }
	  ;
	  
expression_statement returns [std::string place] 	: SEMICOLON	{
	writeIntoparserLogFile("Line " + std::to_string($SEMICOLON->getLine()) + ":" + " expression_statement : SEMICOLON\n");
	writeIntoparserLogFile($SEMICOLON->getText() + "\n");
}	
			| expr=expression SEMICOLON {
	writeIntoparserLogFile("Line " + std::to_string($SEMICOLON->getLine()) + ":" + " expression_statement : expression SEMICOLON\n");
	writeIntoparserLogFile($expr.text + $SEMICOLON->getText() + "\n");
	$place = $expr.place;
			}
			;
	  
variable returns [std::string datatype,std::string place]: ID  {
	writeIntoparserLogFile("Line " + std::to_string($ID->getLine()) + ":" + " variable : ID\n");
	writeIntoparserLogFile($ID->getText() + "\n");
	existing = symbolTable->LookUp($ID->getText());
	if(existing) {
		$datatype = existing->additionalInfo.dataType;
		if(existing->additionalInfo.isArray) {
			writeIntoErrorFile("Error at line " + std::to_string($ID->getLine()) + ": Type mismatch," + $ID->getText() + " is an array" + "\n");
			writeIntoparserLogFile("Error at line " + std::to_string($ID->getLine()) + ": Type mismatch," + $ID->getText() + " is an array" + "\n");
			syntaxErrorCount++;
		}
	}
	else {
		writeIntoErrorFile("Error at line " + std::to_string($ID->getLine()) + ":" + " Undeclared variable " + $ID->getText() + "\n");
		writeIntoparserLogFile("Error at line " + std::to_string($ID->getLine()) + ":" + " Undeclared variable " + $ID->getText() + "\n");
		syntaxErrorCount++;
		$datatype = "error";
	}
	$place = $ID->getText();
}		
	 | ID LTHIRD expr=expression RTHIRD {
	writeIntoparserLogFile("Line " + std::to_string($LTHIRD->getLine()) + ":" + " variable : ID LTHIRD expression RTHIRD\n");
	writeIntoparserLogFile($ID->getText() + $LTHIRD->getText() + $expr.text + $RTHIRD->getText() + "\n");
	existing = symbolTable->LookUp($ID->getText());
	if(existing) {
		$datatype = existing->additionalInfo.dataType;
		if(!existing->additionalInfo.isArray){
			writeIntoparserLogFile("Error at line " + std::to_string($ID->getLine()) + ": " + $ID->getText() + " not an array" + "\n");
			writeIntoErrorFile("Error at line " + std::to_string($ID->getLine()) + ": " + $ID->getText() + " not an array" + "\n");
			syntaxErrorCount++;
		}
	}
	else{
		writeIntoparserLogFile("Error at line " + std::to_string($ID->getLine()) + ":" + " Undeclared variable " + $ID->getText() + "\n");
		writeIntoErrorFile("Error at line " + std::to_string($ID->getLine()) + ":" + " Undeclared variable " + $ID->getText() + "\n");
		syntaxErrorCount++;
		$datatype = "error";
	}
	if($expr.datatype != "int") {
		writeIntoparserLogFile("Error at line " + std::to_string($expr.start->getLine()) + ": Expression inside third brackets not an integer" + "\n");
		writeIntoErrorFile("Error at line " + std::to_string($expr.start->getLine()) + ": Expression inside third brackets not an integer" + "\n");
		syntaxErrorCount++;
	}
	$place = $ID->getText();
	 }
	 ;
	 
 expression returns [std::string datatype,std::string place]: lgexpr=logic_expression	{
	writeIntoparserLogFile("Line " + std::to_string($lgexpr.start->getLine()) + ":" + " expression : logic_expression\n");
	writeIntoparserLogFile($lgexpr.text + "\n");
	$datatype = $lgexpr.datatype;
	$place = $lgexpr.place;
 }
	   | var=variable ASSIGNOP lgexpr=logic_expression  {
	writeIntoparserLogFile("Line " + std::to_string($ASSIGNOP->getLine()) + ":" + " expression : variable ASSIGNOP logic_expression\n");
	writeIntoparserLogFile($var.text + $ASSIGNOP->getText() + $lgexpr.text + "\n");
	$datatype = $var.datatype;
	$place = $var.place;
	existing = symbolTable->LookUp($var.place);
	existing2 = symbolTable->LookUp($lgexpr.place);
	if(existing && existing2) {
		if(existing->additionalInfo.isGlobal && existing2->additionalInfo.isGlobal){
			code += std::string("MOV AX,") + $lgexpr.place + "\n";
			code += std::string("MOV ") + $var.place + ", AX\n";
		}
		else if(existing->additionalInfo.isGlobal && !existing2->additionalInfo.isGlobal) {
			code += std::string("MOV AX,") + "[BP - " + std::to_string(existing2->additionalInfo.offset) + "]\n";
			code += std::string("MOV ") + $var.place + ", AX\n";
		}
		else if(!existing->additionalInfo.isGlobal && existing2->additionalInfo.isGlobal) {
			code += std::string("MOV AX,") + $lgexpr.place + "\n";
			code += std::string("MOV [BP - ") + std::to_string(existing->additionalInfo.offset) + "], AX\n";
		}
		else {
			code += std::string("MOV AX, [BP - ") + std::to_string(existing2->additionalInfo.offset) + "]\n";
			code += std::string("MOV [BP - ") + std::to_string(existing->additionalInfo.offset) + "], AX\n";
		}
	}
	   }	
	   ;
			
logic_expression returns [std::string datatype,std::string place]: rlexpr=rel_expression {
	writeIntoparserLogFile("Line " + std::to_string($rlexpr.start->getLine()) + ":" + " logic_expression : rel_expression\n");
	writeIntoparserLogFile($rlexpr.text + "\n");
	$datatype = $rlexpr.datatype;
	$place = $rlexpr.place;
} 	
		 | rlexpr1=rel_expression LOGICOP rlexpr2=rel_expression {
	writeIntoparserLogFile("Line " + std::to_string($LOGICOP->getLine()) + ":" + " logic_expression : rel_expression LOGICOP rel_expression\n");
	writeIntoparserLogFile($rlexpr1.text + $LOGICOP->getText() + $rlexpr2.text + "\n");
	$datatype = $rlexpr1.datatype;
	$place = newTempVariable();
	existing = symbolTable->LookUp($rlexpr1.place);
	existing2 = symbolTable->LookUp($rlexpr2.place);
	if(existing && existing2) {
		if(existing->additionalInfo.isGlobal && existing2->additionalInfo.isGlobal){
			code += std::string("MOV AX,") + $rlexpr1.place + "\n";
			code += std::string("MOV BX,") + $rlexpr2.place + "\n";
		}
		else if(existing->additionalInfo.isGlobal && !existing2->additionalInfo.isGlobal) {
			code += std::string("MOV AX,") + $rlexpr1.place + "\n";
			code += std::string("MOV BX, [BP - ") + std::to_string(existing2->additionalInfo.offset) + "]\n";
		}
		else if(!existing->additionalInfo.isGlobal && existing2->additionalInfo.isGlobal) {
			code += std::string("MOV AX, [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
			code += std::string("MOV BX,") + $rlexpr2.place + "\n";
		}
		else {
			code += std::string("MOV AX, [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
			code += std::string("MOV BX, [BP - ") + std::to_string(existing2->additionalInfo.offset) + "]\n";
		}
		if($LOGICOP->getText() == "&&") {
			code += "AND AX, BX\n";
			code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
		}
		else if($LOGICOP->getText() == "||") {
			code += "OR AX, BX\n";
			code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
	    }
		}
	}	
		 ;
			
rel_expression	returns [std::string datatype,std::string place]: smexpr=simple_expression {
	writeIntoparserLogFile("Line " + std::to_string($smexpr.start->getLine()) + ":" + " rel_expression : simple_expression\n");
	writeIntoparserLogFile($smexpr.text + "\n");
	$datatype = $smexpr.datatype;
	$place = $smexpr.place;
}
		| smexpr1=simple_expression RELOP smexpr2=simple_expression	{
	writeIntoparserLogFile("Line " + std::to_string($RELOP->getLine()) + ":" + " rel_expression : simple_expression RELOP simple_expression\n");
	writeIntoparserLogFile($smexpr1.text + $RELOP->getText() + $smexpr2.text + "\n");
	$datatype = $smexpr1.datatype;
	$place = newTempVariable();
	existing = symbolTable->LookUp($smexpr1.place);
	existing2 = symbolTable->LookUp($smexpr2.place);
	if(existing && existing2) {
		if(existing->additionalInfo.isGlobal && existing2->additionalInfo.isGlobal){
			code += std::string("MOV AX,") + $smexpr1.place + "\n";
			code += std::string("MOV BX,") + $smexpr2.place + "\n";
		}
		else if(existing->additionalInfo.isGlobal && !existing2->additionalInfo.isGlobal) {
			code += std::string("MOV AX,") + $smexpr1.place + "\n";
			code += std::string("MOV BX, [BP - ") + std::to_string(existing2->additionalInfo.offset) + "]\n";
		}
		else if(!existing->additionalInfo.isGlobal && existing2->additionalInfo.isGlobal) {
			code += std::string("MOV AX, [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
			code += std::string("MOV BX,") + $smexpr2.place + "\n";
		}
		else {
			code += std::string("MOV AX, [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
			code += std::string("MOV BX, [BP - ") + std::to_string(existing2->additionalInfo.offset) + "]\n";
		}
		if($RELOP->getText() == "==") {
			code += "CMP AX, BX\n";
			str = newLabel();
			code += std::string("JE ") + str + "\n";
			code += std::string("MOV AX, 0\n");
			code += std::string("JMP ") + str + "_end\n";
			code += str + ":\n";
			code += std::string("MOV AX, 1\n");
			code += str + "_end:\n";
			code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
		}
		else if($RELOP->getText() == "!=") {
			code += "CMP AX, BX\n";
			str = newLabel();
			code += std::string("JNE ") + str + "\n";
			code += std::string("MOV AX, 0\n");
			code += std::string("JMP ") + str + "_end\n";
			code += str + ":\n";
			code += std::string("MOV AX, 1\n");
			code += str + "_end:\n";
			code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
		}
		else if($RELOP->getText() == "<") {
			code += "CMP AX, BX\n";
			str = newLabel();
			code += std::string("JL ") + str + "\n";
			code += std::string("MOV AX, 0\n");
			code += std::string("JMP ") + str + "_end\n";
			code += str + ":\n";
			code += std::string("MOV AX, 1\n");
			code += str + "_end:\n";
			code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
		}
		else if($RELOP->getText() == "<=") {
			code += "CMP AX, BX\n";
			str = newLabel();
			code += std::string("JLE ") + str + "\n";
			code += std::string("MOV AX, 0\n");
			code += std::string("JMP ") + str + "_end\n";
			code += str + ":\n";
			code += std::string("MOV AX, 1\n");
			code += str + "_end:\n";
			code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
		}
		else if($RELOP->getText() == ">") {
			code += "CMP AX, BX\n";
			str = newLabel();
			code += std::string("JG ") + str + "\n";
			code += std::string("MOV AX, 0\n");
			code += std::string("JMP ") + str + "_end\n";
			code += str + ":\n";
			code += std::string("MOV AX, 1\n");
			code += str + "_end:\n";
			code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
		}
		else if($RELOP->getText() == ">=") {
			code += "CMP AX, BX\n";
			str = newLabel();
			code += std::string("JGE ") + str + "\n";
			code += std::string("MOV AX, 0\n");
			code += std::string("JMP ") + str + "_end\n";
			code += str + ":\n";
			code += std::string("MOV AX, 1\n");
			code += str + "_end:\n";
			code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
		}
	}
		}
		;
				
simple_expression returns [std::string datatype,std::string place]: trm=term {
	writeIntoparserLogFile("Line " + std::to_string($trm.start->getLine()) + ":" + " simple_expression : term\n");
	writeIntoparserLogFile($trm.text + "\n");
	$datatype = $trm.datatype;
	$place = $trm.place;
}
		  | smexpr=simple_expression ADDOP trm=term {
	writeIntoparserLogFile("Line " + std::to_string($ADDOP->getLine()) + ":" + " simple_expression : simple_expression ADDOP term\n");
	writeIntoparserLogFile($smexpr.text + $ADDOP->getText() + $trm.text + "\n");
	if($smexpr.datatype == "float" || $trm.datatype == "float") {
		$datatype = "float";
	}
	else{
		$datatype = "int";
	}
	$place = newTempVariable();
	existing = symbolTable->LookUp($smexpr.place);
	existing2 = symbolTable->LookUp($trm.place);
	if(existing && existing2) {
		if($ADDOP->getText() == "+") {
			if(existing->additionalInfo.isGlobal && existing2->additionalInfo.isGlobal) {
				code += std::string("MOV AX,") + $smexpr.place + "\n";
				code += std::string("MOV BX,") + $trm.place + "\n";
				code += std::string("ADD AX, BX\n");
				code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
			}
			else if(existing->additionalInfo.isGlobal && !existing2->additionalInfo.isGlobal) {
				code += std::string("MOV AX,") + $smexpr.place + "\n";
				code += std::string("MOV BX, [BP - ") + std::to_string(existing2->additionalInfo.offset) + "]\n";
				code += std::string("ADD AX, BX\n");
				code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
			}
			else if(!existing->additionalInfo.isGlobal && existing2->additionalInfo.isGlobal) {
				code += std::string("MOV AX, [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
				code += std::string("MOV BX,") + $trm.place + "\n";
				code += std::string("ADD AX, BX\n");
				code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
			}
			else {
				code += std::string("MOV AX, [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
				code += std::string("MOV BX, [BP - ") + std::to_string(existing2->additionalInfo.offset) + "]\n";
				code += std::string("ADD AX, BX\n");
				code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
			}
		}
		else if($ADDOP->getText() == "-") {
			if(existing->additionalInfo.isGlobal && existing2->additionalInfo.isGlobal) {
				code += std::string("MOV AX,") + $smexpr.place + "\n";
				code += std::string("MOV BX,") + $trm.place + "\n";
				code += std::string("SUB AX, BX\n");
				code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
			}
			else if(existing->additionalInfo.isGlobal && !existing2->additionalInfo.isGlobal) {
				code += std::string("MOV AX,") + $smexpr.place + "\n";
				code += std::string("MOV BX, [BP - ") + std::to_string(existing2->additionalInfo.offset) + "]\n";
				code += std::string("SUB AX, BX\n");
				code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
			}
			else if(!existing->additionalInfo.isGlobal && existing2->additionalInfo.isGlobal) {
				code += std::string("MOV AX, [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
				code += std::string("MOV BX	,") + $trm.place + "\n";
				code += std::string("SUB AX, BX\n");
				code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
			}
			else {
				code += std::string("MOV AX, [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
				code += std::string("MOV BX, [BP - ") + std::to_string(existing2->additionalInfo.offset) + "]\n";
				code += std::string("SUB AX, BX\n");
				code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
			}
		}
	}
	}
		  ;
					
term returns [std::string datatype,std::string place]:	unexpr=unary_expression {
	writeIntoparserLogFile("Line " + std::to_string($unexpr.start->getLine()) + ":" + " term : unary_expression\n");
	writeIntoparserLogFile($unexpr.text + "\n");
	$datatype = $unexpr.datatype;
	$place = $unexpr.place;
}
     |  trm=term MULOP unexpr=unary_expression {
	writeIntoparserLogFile("Line " + std::to_string($MULOP->getLine()) + ":" + " term : term MULOP unary_expression\n");
	writeIntoparserLogFile($trm.text + $MULOP->getText() + $unexpr.text + "\n");
	if($trm.datatype == "float" || $unexpr.datatype == "float") {
		$datatype = "float";
	}
	if($MULOP->getText() == "%"){
		$datatype = "int";
	}
	else{
		$datatype = "int";
	}
	$place = newTempVariable();
	existing = symbolTable->LookUp($trm.place);
	existing2 = symbolTable->LookUp($unexpr.place);
	if(existing && existing2) {
		if($MULOP->getText() == "*") {
			if(existing->additionalInfo.isGlobal && existing2->additionalInfo.isGlobal) {
				code += std::string("MOV AX,") + $trm.place + "\n";
				code += std::string("MOV BX,") + $unexpr.place + "\n";
				code += std::string("MUL BX\n");
				code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
			}
			else if(existing->additionalInfo.isGlobal && !existing2->additionalInfo.isGlobal) {
				code += std::string("MOV AX,") + $trm.place + "\n";
				code += std::string("MOV BX, [BP - ") + std::to_string(existing2->additionalInfo.offset) + "]\n";
				code += std::string("MUL BX\n");
				code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
			}
			else if(!existing->additionalInfo.isGlobal && existing2->additionalInfo.isGlobal) {
				code += std::string("MOV AX, [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
				code += std::string("MOV BX,") + $unexpr.place + "\n";
				code += std::string("MUL BX\n");
				code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
			}
			else {
				code += std::string("MOV AX, [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
				code += std::string("MOV BX, [BP - ") + std::to_string(existing2->additionalInfo.offset) + "]\n";
				code += std::string("MUL BX\n");
				code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
			}
		}
		else if($MULOP->getText() == "/") {
			if(existing->additionalInfo.isGlobal && existing2->additionalInfo.isGlobal) {
				code += std::string("MOV AX,") + $trm.place + "\n";
				code += std::string("MOV BX,") + $unexpr.place + "\n";
				code += std::string("DIV BX\n");
				code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
			}
			else if(existing->additionalInfo.isGlobal && !existing2->additionalInfo.isGlobal) {
				code += std::string("MOV AX,") + $trm.place + "\n";
				code += std::string("MOV BX, [BP - ") + std::to_string(existing2->additionalInfo.offset) + "]\n";
				code += std::string("DIV BX\n");
				code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
			}
			else if(!existing->additionalInfo.isGlobal && existing2->additionalInfo.isGlobal) {
				code += std::string("MOV AX, [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
				code += std::string("MOV BX	,") + $unexpr.place + "\n";
				code += std::string("DIV BX\n");
				code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
			}
			else {
				code += std::string("MOV AX, [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
				code += std::string("MOV BX, [BP - ") + std::to_string(existing2->additionalInfo.offset) + "]\n";
				code += std::string("DIV BX\n");
				code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
			}
	    }
		else if($MULOP->getText() == "%") {
			if(existing->additionalInfo.isGlobal && existing2->additionalInfo.isGlobal) {
				code += std::string("MOV AX,") + $trm.place + "\n";
				code += std::string("MOV BX,") + $unexpr.place + "\n";
				code += std::string("XOR DX, DX\n");
				code += std::string("DIV BX\n");
				code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], DX\n";
			}
			else if(existing->additionalInfo.isGlobal && !existing2->additionalInfo.isGlobal) {
				code += std::string("MOV AX,") + $trm.place + "\n";
				code += std::string("MOV BX, [BP - ") + std::to_string(existing2->additionalInfo.offset) + "]\n";
				code += std::string("XOR DX, DX\n");
				code += std::string("DIV BX\n");
				code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], DX\n";
			}
			else if(!existing->additionalInfo.isGlobal && existing2->additionalInfo.isGlobal) {
				code += std::string("MOV AX, [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
				code += std::string("MOV BX,") + $unexpr.place + "\n";
				code += std::string("XOR DX, DX\n");
				code += std::string("DIV BX\n");
				code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], DX\n";
			}
			else {
				code += std::string("MOV AX, [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
				code += std::string("MOV BX, [BP - ") + std::to_string(existing2->additionalInfo.offset) + "]\n";
				code += std::string("XOR DX, DX\n");
				code += std::string("DIV BX\n");
				code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], DX\n";
			}
	 }
	}
	 } 		
     ;

unary_expression returns [std::string datatype,std::string place]: ADDOP unexpr=unary_expression  {
		writeIntoparserLogFile("Line " + std::to_string($ADDOP->getLine()) + ":" + " unary_expression : ADDOP unary_expression\n");
		writeIntoparserLogFile($ADDOP->getText() + $unexpr.text + "\n");
		$datatype = $unexpr.datatype;
		if($ADDOP->getText() == "+") {
			$place = $unexpr.place;
		}
		else if($ADDOP->getText() == "-") {
			existing = symbolTable->LookUp($unexpr.place);
			if(existing) {
				if(existing->additionalInfo.isGlobal) {
					$place = newTempVariable();
					code  += std::string("MOV AX,") + $unexpr.place + "\n";
					code += std::string("NEG AX\n");
					code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
				}
				else {
					$place = newTempVariable();
					code  += std::string("MOV AX, [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
					code += std::string("NEG AX\n");
					code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
				}
			}
		}
}
		| NOT unexpr=unary_expression {
		writeIntoparserLogFile("Line " + std::to_string($NOT->getLine()) + ":" + " unary_expression : NOT unary_expression\n");
		writeIntoparserLogFile($NOT->getText() + $unexpr.text + "\n");
		$datatype = "int";
		$place = newTempVariable();
		existing = symbolTable->LookUp($unexpr.place);
		if(existing) {
			if(existing->additionalInfo.isGlobal) {
				code += std::string("MOV AX,") + $unexpr.place + "\n";
				code += std::string("NOT AX\n");
				code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
			}
			else {
				code += std::string("MOV AX, [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
				code += std::string("NOT AX\n");
				code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
			}
		}
		}
		| fctr=factor {
		writeIntoparserLogFile("Line " + std::to_string($fctr.start->getLine()) + ":" + " unary_expression : factor\n");
		writeIntoparserLogFile($fctr.text + "\n");
		$datatype = $fctr.datatype;
		$place = $fctr.place;
		}
		 ;
	
factor returns [std::string datatype,std::string place]	: var=variable {
		writeIntoparserLogFile("Line " + std::to_string($var.start->getLine()) + ":" + " factor : variable\n");
		writeIntoparserLogFile($var.text + "\n");
		$datatype = $var.datatype;
		$place = $var.place;
    }
	| id=ID lp=LPAREN argl=argument_list rp=RPAREN {
		writeIntoparserLogFile("Line " + std::to_string($argl.start->getLine()) + ":" + " factor : ID LPAREN argument_list RPAREN\n");
		writeIntoparserLogFile($id.text + $lp.text + $argl.text + $rp.text + "\n");
		existing = symbolTable->LookUp($id.text);
		if(existing && existing->additionalInfo.isDefined && existing->additionalInfo.isFunction){
			$datatype = existing->additionalInfo.returnType;
			if($argl.argtypes != existing->additionalInfo.parameters){
			if(existing->additionalInfo.parameters.size() != $argl.argtypes.size()){
				writeIntoErrorFile("Error at line " + std::to_string($id->getLine()) + ":" + " Total number of argument mismatch in function " + $id.text + "\n");
				writeIntoparserLogFile("Error at line " + std::to_string($id->getLine()) + ":" + " Total number of argument mismatch in function " + $id.text + "\n");
				syntaxErrorCount++;
			}
			else{
				for(int i = 0; i < $argl.argtypes.size(); i++){
					if($argl.argtypes[i] != existing->additionalInfo.parameters[i]){
						writeIntoErrorFile("Error at line " + std::to_string($id->getLine()) + ": " + std::to_string(i+1) + "th argument mismatch in function " + $id.text + "\n");
						writeIntoparserLogFile("Error at line " + std::to_string($id->getLine()) + ": " + std::to_string(i+1) + "th argument mismatch in function " + $id.text + "\n");
						syntaxErrorCount++;
						break;
					}
				}
			}
		}
		}
		else{
			writeIntoErrorFile("Error at line " + std::to_string($id->getLine()) + ":" + " Undeclared function " + $id.text + "\n");
			writeIntoparserLogFile("Error at line " + std::to_string($id->getLine()) + ":" + " Undeclared function " + $id.text + "\n");
			syntaxErrorCount++;
			$datatype = "error";
		}
	}
	| lp=LPAREN expr=expression rp=RPAREN {
		writeIntoparserLogFile("Line " + std::to_string($expr.start->getLine()) + ":" + " factor : LPAREN expression RPAREN\n");
		writeIntoparserLogFile($lp.text + $expr.text + $rp.text + "\n");
		$datatype = $expr.datatype;
		$place = $expr.place;
	}
	| CONST_INT {
		writeIntoparserLogFile("Line " + std::to_string($CONST_INT->getLine()) + ":" + " factor : CONST_INT\n");
		writeIntoparserLogFile($CONST_INT->getText() + "\n");
		$datatype = "int";
		$place = newTempVariable();
		code += std::string("MOV ") + "WORD PTR[BP - " + std::to_string(stackOffset) + "], " + $CONST_INT->getText() + "\n";
	}
	| CONST_FLOAT {
		writeIntoparserLogFile("Line " + std::to_string($CONST_FLOAT->getLine()) + ":" + " factor : CONST_FLOAT\n");
		writeIntoparserLogFile($CONST_FLOAT->getText() + "\n");
		$datatype = "float";
	}
	| var=variable INCOP {
		writeIntoparserLogFile("Line " + std::to_string($INCOP->getLine()) + ":" + " factor : variable INCOP\n");
		writeIntoparserLogFile($INCOP->getText() + "\n");
		$datatype = $var.datatype;
		$place = newTempVariable();
		existing = symbolTable->LookUp($var.place);
		if(existing){
			if(existing->additionalInfo.isGlobal){
				if(!existing->additionalInfo.isArray){
					code += std::string("MOV AX,") + $var.place + "\n";
					code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
					code += std::string("INC ") + $var.place + "\n";
				}
				else{
					
				}
			}
			else{
				if(!existing->additionalInfo.isArray){
					code += std::string("MOV AX, [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
					code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
					code += std::string("INC [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
				}
				else{

				}
			}
		}
	}
	| var=variable DECOP {
		writeIntoparserLogFile("Line " + std::to_string($DECOP->getLine()) + ":" + " factor : variable DECOP\n");
		writeIntoparserLogFile($DECOP->getText() + "\n");
		$datatype = $var.datatype;
		$place = newTempVariable();
		existing = symbolTable->LookUp($var.place);
		if(existing){
			if(existing->additionalInfo.isGlobal){
				if(!existing->additionalInfo.isArray){
					code += std::string("MOV AX,") + $var.place + "\n";
					code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
					code += std::string("DEC ") + $var.place + "\n";
				}
				else{
					
				}
			}
			else{
				if(!existing->additionalInfo.isArray){
					code += std::string("MOV AX, [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
					code += std::string("MOV [BP - ") + std::to_string(stackOffset) + "], AX\n";
					code += std::string("INC [BP - ") + std::to_string(existing->additionalInfo.offset) + "]\n";
				}
				else{

				}
			}
		}	
	}
	;
	
argument_list returns [std::vector<std::string> argtypes]: args=arguments {
			writeIntoparserLogFile("Line " + std::to_string($args.start->getLine()) + ":" + " argument_list : arguments\n");
			writeIntoparserLogFile($args.text + "\n");
			$argtypes = $args.argtypes;
            }
			  | {
				$argtypes = std::vector<std::string>();
			  }
			  ;
	
arguments returns [std::vector<std::string> argtypes]: args=arguments cm=COMMA le=logic_expression {
			writeIntoparserLogFile("Line " + std::to_string($le.start->getLine()) + ":" + " arguments : arguments COMMA logic_expression\n");
			writeIntoparserLogFile($args.text + $cm.text + $le.text + "\n");
			$argtypes = $args.argtypes;
			$argtypes.push_back($le.datatype);
          }
	      | le=logic_expression {
			writeIntoparserLogFile("Line " + std::to_string($le.start->getLine()) + ":" + " arguments : logic_expression\n");
			writeIntoparserLogFile($le.text + "\n");
			$argtypes.push_back($le.datatype);
		  }
	      ;